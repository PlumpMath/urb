# :: ufo - a stack-based lisp language ::
#
# special is like dig a hole to wait for arguments
# then execute when it has enough.
# special form can goes for special hole
# when statement is evaluated post-fix order.
#
###############################################
(def (x:int -> square:int) 
	 (((x x *) return)))

(12 square) # get eval anyway but don't store.

#
# @ - uneval mode 
# ! - eval mode
#
(12 13 square map) # goes on evaluation stack for the result.

(1 2 3 + reduce) # => 6 on stack.

(System System.IO using map)

(Urb namespace)

(MainClass :partial :public :static class)

("deulamco" Name :public set)

("Static variable." StaticA :public :static set)

((Stack<List<object>> new) listStack :public :static set)

(def (_ -> Main:void) :static :public
	(((ULisp new) uLisp var)))

(def (_ -> ToString:string) :public :override
	((" ToString is overrided." return)))

(def (_ -> static_method:void) :static :private
	((" This's static method." Console.WriteLine)))

(def (_ -> test:void) :private
	((Condition label)
	 (0 i var)
	 (1 i +=)
	 (i Console.WriteLine)
	 (((-1 i <) 
	   (10 i <)
	   (true false or) and)
	  (Condition jump) if)
	 (i result var)
	 (result Console.WriteLine)))

(def (x:float y:float z:float -> set_position:void) :public
	(((
	  (transform.position.z z +)
	  (transform.position.y y +)
	  (transform.position.x x +)
	  Vector3 new) transform.position =)))

(def (_ -> Update:void)
	(((KeyCode.DownArrow Input.GetKey)
	  (0f -1.0f 0f set_position) if)))

(endclass)
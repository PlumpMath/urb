======================================================
==													==
==    ::  - a stack-based lisp language ::    ==
==													==
======================================================

== : is attractor operator, which attract all tokens in a block into it like a definition.
== [] is un-eval brace annotation.
== << is assignment operator.
== functional pattern matching featured.
== |  guard for case matching.
== -> annotation for next act if case matched.

== primitives types: Int32, Float, Double, Bool, String, Symbol
== data types: List, Stack

(:listA 1 2 3) => var listA = List<Int32>(){1, 2, 3};

(:listB a b c) => var listB = List<Symbol>(){a, b, c};


== because bailey aim for freedom so no special order or tabs are required.
(:square | 0 -> 0 | 1 -> 1 | n -> n n * )

== or pretty in order a bit.
(:factorial 
    | 0 -> 0
    | 1 -> 1 
    | n -> n n 1 - factorial * )

== forced into a code block help reduce overloads matching complexity.
(2 square factorial) ===> 24

== mapping function as 1st class.
(System System.IO [ using ] map)

== unknown typing will be delayed.
(:sum [ + ] reduce )

== generic list processing.
(:list-split
	| []         -> 						 "empty" print 
	| head::tail -> head tail "head {0} :: tail {1}" print )

== strong typed depend on type inference.
(:print 
	| object[]/arg String/str -> arg str Console.WriteLine 
    | String/str              ->     str Console.WriteLine )

== void return because no function return.
(:set-position 
    | 0f 0f 0f -> ignore
    | x  y  z  -> [transform.position] p label 
	                p.x x + p.y y + p.z z + Vector3 new p << )
                     
 
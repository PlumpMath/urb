######################################################
#													 #
#    :: ufo - a stack-based lisp language ::         #
#													 #
# special is like dig a hole to wait for arguments	 #
# then execute when it has enough.					 #
# special form can goes for special hole			 #
# when statement is evaluated post-fix order.		 #
#													 #
######################################################
(def (square -> x)
	 (int 	 -> int)
	 (progn
	 	(return (* x x))))

(square 12)

###################
#				  #
# @ - uneval mode #
# ! - eval mode   #
#				  #
###################
(map square @(12 13))
(reduce + @(1 2 3))

(map using @(System System.IO))

(namespace Urb)

(class MainClass @(:partial :static :public) (progn)) 

(set listStack @(:public :static) (new Stack<List<object>>))

###########################################
#										  #
# better style and better at structure.   #
# we need cleaner code, not shorter mess. #
#										  #
###########################################
(def (sum -> a b c) 
	 (int -> int int int)
	 (:static :private)
	 (progn
	 	(return 
	 		(+ a b c)))) 


##########################################
#										 #
# post-fix lisp seem harder to forward.  #
# also harder to read and ordering.		 #
#										 #
# but learning to take use of stack is   #
# a very great chance for compiling.     #
#										 #
##########################################
(def (static_method -> _)
	 (void 			-> _)
	 (:static :private)
	 (progn
	 	(Console.WriteLine "This's static method")))


(def (set_position -> x y z)
     (void         -> float float float)
     (:public)
	 (progn
 		####################################
	    # 								   #
	    # '=' assignment is different from #
	    # 'set' because set work outside   # 
	    # method, when '=' is inside.	   #
	    #								   #
	    ####################################
	  	(= transform.position 
		    (new Vector3 
		    (+ transform.position.x x)
		    (+ transform.position.y y)
	 	    (+ transform.position.z z)))))